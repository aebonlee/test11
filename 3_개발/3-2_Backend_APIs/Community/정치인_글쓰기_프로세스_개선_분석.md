# 정치인 글쓰기/댓글 프로세스 개선 분석

## 목차
1. [현재 구현 상태 (As-Is)](#현재-구현-상태-as-is)
2. [필요한 구현 (To-Be)](#필요한-구현-to-be)
3. [데이터베이스 변경 사항](#데이터베이스-변경-사항)
4. [API 변경 사항](#api-변경-사항)
5. [구현 계획](#구현-계획)

---

## 현재 구현 상태 (As-Is)

### 1. 글쓰기 프로세스 (`/api/posts/route.ts`)

#### 인증 방식
```typescript
// 1. requireAuth() 필수
const authResult = await requireAuth();
const { user } = authResult;

// → 일반 회원 인증만 가능
// → 정치인은 글쓰기 불가능
```

#### 데이터 삽입
```typescript
const { data: newPost } = await supabase
  .from("posts")
  .insert({
    user_id: user.id,  // ← 필수 필드 (NOT NULL)
    title: validated.title,  // ← "title" 필드명 (개선 필요)
    content: validated.content,
    category: validated.category,
    politician_id: validated.politician_id || null,  // ← 선택적
    tags: validated.tags || null,
  })
  .select()
  .single();
```

#### 스키마 검증
```typescript
const createPostSchema = z.object({
  title: z.string().min(5).max(200),  // ← "title" 필드명
  content: z.string().min(10).max(10000),
  category: z.enum(["general", "question", "debate", "news"]),
  politician_id: z.string().uuid().optional().nullable(),
  tags: z.array(z.string()).max(5).optional(),
});
```

#### 문제점
- ❌ 정치인은 글쓰기 불가능 (requireAuth 필수)
- ❌ user_id가 항상 필요함 (NOT NULL)
- ❌ politician_id는 있지만 인증 용도로 사용되지 않음
- ❌ "title" 필드명이 혼란스러움 (정치인 position도 title)

---

### 2. 댓글 쓰기 프로세스 (`/api/comments/route.ts`)

#### 인증 방식
```typescript
// 1. requireAuth() 필수
const authResult = await requireAuth();
const { user } = authResult;

// → 일반 회원 인증만 가능
// → 정치인은 댓글 쓰기 불가능
```

#### 데이터 삽입
```typescript
const { data: newComment } = await supabase
  .from('comments')
  .insert({
    post_id: validated.post_id,
    content: validated.content,
    user_id: user.id,  // ← 필수 필드 (NOT NULL)
    parent_id: validated.parent_id || null,
  })
  .select()
  .single();
```

#### 스키마 검증
```typescript
const createCommentSchema = z.object({
  post_id: z.string().min(1, "게시글 ID는 필수입니다"),
  content: z.string().min(1, "댓글 내용은 필수입니다").max(500),
  parent_id: z.string().optional().nullable(),
});
```

#### 문제점
- ❌ 정치인은 댓글 쓰기 불가능 (requireAuth 필수)
- ❌ user_id가 항상 필요함 (NOT NULL)
- ❌ politician_id 필드 자체가 없음

---

### 3. 조회 프로세스

#### 게시글 조회 (`GET /api/posts`)
```typescript
// posts와 users 조인
let queryBuilder = supabase
  .from('posts')
  .select(`
    *,
    users:user_id (
      name,
      email
    ),
    politician:politician_id (
      name,
      party,
      position
    )
  `, { count: 'exact' });
```

#### 댓글 조회 (`GET /api/comments`)
```typescript
// comments와 users 조인
let queryBuilder = supabase
  .from('comments')
  .select(`
    *,
    users:user_id (
      name,
      email
    ),
    posts:post_id (
      title  // ← "title" 필드명
    )
  `, { count: 'exact' });
```

#### 문제점
- ⚠️ 정치인 정보 조인이 없음 (comments)
- ⚠️ "title" 필드명 사용

---

## 필요한 구현 (To-Be)

### 1. 정치인 글쓰기 프로세스

#### 플로우
```
1. "글쓰기" 버튼 클릭
   ↓
2. 정치인 선택 (드롭다운)
   ↓
3. localStorage 세션 확인
   ↓
4-A. ✅ verified_email 있음
   → 바로 글쓰기 화면

4-B. ❌ verified_email 없음
   → 이메일 입력
   → 인증 코드 발송
   → 코드 확인
   → verified_email 저장
   → 글쓰기 화면
```

#### API 요청 형태
```typescript
// 정치인 글쓰기
POST /api/posts
{
  "politician_id": "62e7b453",
  "session_token": "a1b2c3d4...",
  "subject": "제목",
  "content": "내용",
  "category": "general",
  "author_type": "politician"
}
```

#### 서버 검증 로직
```typescript
// 1. author_type 확인
if (author_type === 'politician') {
  // 2. session_token 검증
  const { data: session } = await supabase
    .from('politician_sessions')
    .select('*')
    .eq('politician_id', politician_id)
    .eq('session_token', session_token)
    .gt('expires_at', new Date().toISOString())  // 2099년까지 유효
    .single();

  if (!session) {
    return error('인증이 필요합니다');
  }

  // 3. 게시글 삽입
  await supabase
    .from('posts')
    .insert({
      user_id: null,  // ← NULL 허용
      politician_id: politician_id,  // ← 정치인 ID
      subject: validated.subject,
      content: validated.content,
      author_type: 'politician',
    });
}
```

---

### 2. 정치인 댓글 쓰기 프로세스

#### 플로우
```
1. 댓글 작성 클릭
   ↓
2. localStorage 세션 확인
   ↓
3-A. ✅ verified_email 있음
   → 바로 댓글 작성

3-B. ❌ verified_email 없음
   → 이메일 입력
   → 인증 코드 발송
   → 코드 확인
   → verified_email 저장
   → 댓글 작성
```

#### API 요청 형태
```typescript
// 정치인 댓글 쓰기
POST /api/comments
{
  "post_id": "post-uuid",
  "politician_id": "62e7b453",
  "session_token": "a1b2c3d4...",
  "content": "댓글 내용",
  "author_type": "politician"
}
```

#### 서버 검증 로직
```typescript
// 1. author_type 확인
if (author_type === 'politician') {
  // 2. session_token 검증
  const { data: session } = await supabase
    .from('politician_sessions')
    .select('*')
    .eq('politician_id', politician_id)
    .eq('session_token', session_token)
    .gt('expires_at', new Date().toISOString())
    .single();

  if (!session) {
    return error('인증이 필요합니다');
  }

  // 3. 댓글 삽입
  await supabase
    .from('comments')
    .insert({
      post_id: validated.post_id,
      user_id: null,  // ← NULL 허용
      politician_id: politician_id,  // ← 정치인 ID
      content: validated.content,
      author_type: 'politician',
    });
}
```

---

## 데이터베이스 변경 사항

### 1. `politicians` 테이블

#### 추가 필드
```sql
ALTER TABLE politicians
  ADD COLUMN IF NOT EXISTS verified_email TEXT UNIQUE;

ALTER TABLE politicians
  ADD COLUMN IF NOT EXISTS email_verified_at TIMESTAMPTZ;
```

**설명:**
- `verified_email`: 한번 인증된 이메일 (영구 사용)
- `email_verified_at`: 최초 인증 시간

---

### 2. `posts` 테이블

#### 변경 사항
```sql
-- 1. title → subject 변경
ALTER TABLE posts RENAME COLUMN title TO subject;

-- 2. user_id를 NULLABLE로 변경
ALTER TABLE posts ALTER COLUMN user_id DROP NOT NULL;

-- 3. author_type 추가
ALTER TABLE posts
  ADD COLUMN IF NOT EXISTS author_type TEXT DEFAULT 'user'
  CHECK (author_type IN ('user', 'politician'));

-- 4. CHECK 제약 조건 추가 (user_id OR politician_id 필수)
ALTER TABLE posts
  ADD CONSTRAINT posts_author_check
  CHECK (
    (user_id IS NOT NULL AND politician_id IS NULL) OR
    (user_id IS NULL AND politician_id IS NOT NULL)
  );
```

**설명:**
- `subject`: "title" → "subject"로 변경 (혼란 방지)
- `user_id`: NULL 허용 (정치인 글은 user_id 없음)
- `author_type`: 'user' 또는 'politician' (작성자 유형)
- CHECK 제약: user_id OR politician_id 중 하나는 반드시 있어야 함

---

### 3. `comments` 테이블

#### 변경 사항
```sql
-- 1. user_id를 NULLABLE로 변경
ALTER TABLE comments ALTER COLUMN user_id DROP NOT NULL;

-- 2. politician_id 추가
ALTER TABLE comments
  ADD COLUMN IF NOT EXISTS politician_id TEXT
  REFERENCES politicians(id) ON DELETE SET NULL;

-- 3. author_type 추가
ALTER TABLE comments
  ADD COLUMN IF NOT EXISTS author_type TEXT DEFAULT 'user'
  CHECK (author_type IN ('user', 'politician'));

-- 4. CHECK 제약 조건 추가
ALTER TABLE comments
  ADD CONSTRAINT comments_author_check
  CHECK (
    (user_id IS NOT NULL AND politician_id IS NULL) OR
    (user_id IS NULL AND politician_id IS NOT NULL)
  );
```

**설명:**
- `user_id`: NULL 허용
- `politician_id`: 정치인 ID (새로 추가)
- `author_type`: 'user' 또는 'politician'
- CHECK 제약: user_id OR politician_id 중 하나는 필수

---

### 4. `politician_sessions` 테이블

#### 생성
```sql
CREATE TABLE IF NOT EXISTS politician_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  politician_id TEXT NOT NULL REFERENCES politicians(id) ON DELETE CASCADE,
  session_token TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,  -- 2099-12-31 (영구)
  last_used_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  ip_address TEXT,
  user_agent TEXT
);

CREATE INDEX idx_politician_sessions_token ON politician_sessions(session_token);
CREATE INDEX idx_politician_sessions_politician ON politician_sessions(politician_id);
```

**설명:**
- 정치인 영구 세션 저장
- `expires_at`: 2099-12-31 (실질적으로 영구)
- `session_token`: 64자리 hex (보안)

---

### 5. `email_verifications` 테이블

#### 수정 (이미 존재하는 경우)
```sql
-- purpose 값에 'email_registration' 추가
ALTER TABLE email_verifications
  DROP CONSTRAINT IF EXISTS email_verifications_purpose_check;

ALTER TABLE email_verifications
  ADD CONSTRAINT email_verifications_purpose_check
  CHECK (purpose IN ('email_registration', 'posting', 'comment', 'report_purchase'));
```

---

## API 변경 사항

### 1. `/api/posts/route.ts` - POST 수정

#### 변경 전
```typescript
export async function POST(request: NextRequest) {
  // 1. 인증 필수
  const authResult = await requireAuth();
  const { user } = authResult;

  // 2. 스키마 검증
  const createPostSchema = z.object({
    title: z.string().min(5).max(200),
    // ...
  });

  // 3. 삽입
  const { data: newPost } = await supabase
    .from("posts")
    .insert({
      user_id: user.id,  // 필수
      title: validated.title,
      // ...
    });
}
```

#### 변경 후
```typescript
export async function POST(request: NextRequest) {
  const body = await request.json();

  // 1. author_type에 따라 분기
  if (body.author_type === 'politician') {
    // === 정치인 글쓰기 ===

    // 1-1. 스키마 검증
    const politicianPostSchema = z.object({
      politician_id: z.string().min(8).max(8),
      session_token: z.string().min(64).max(64),
      subject: z.string().min(5).max(200),
      content: z.string().min(10).max(10000),
      category: z.enum(["general", "question", "debate", "news"]),
      tags: z.array(z.string()).max(5).optional(),
      author_type: z.literal('politician'),
    });

    const validated = politicianPostSchema.parse(body);

    // 1-2. 세션 토큰 검증
    const supabase = createAdminClient();
    const { data: session, error: sessionError } = await supabase
      .from('politician_sessions')
      .select('*')
      .eq('politician_id', validated.politician_id)
      .eq('session_token', validated.session_token)
      .gt('expires_at', new Date().toISOString())
      .single();

    if (sessionError || !session) {
      return NextResponse.json(
        { error: '인증이 필요합니다. 다시 로그인해주세요.' },
        { status: 401 }
      );
    }

    // 1-3. 게시글 삽입
    const { data: newPost, error: insertError } = await supabase
      .from('posts')
      .insert({
        user_id: null,
        politician_id: validated.politician_id,
        subject: validated.subject,
        content: validated.content,
        category: validated.category,
        tags: validated.tags || null,
        author_type: 'politician',
      })
      .select()
      .single();

    if (insertError) {
      return NextResponse.json(
        { error: '게시글 작성 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }

    // 1-4. last_used_at 업데이트
    await supabase
      .from('politician_sessions')
      .update({ last_used_at: new Date().toISOString() })
      .eq('id', session.id);

    return NextResponse.json({ success: true, data: newPost }, { status: 201 });

  } else {
    // === 일반 회원 글쓰기 (기존 로직) ===

    const authResult = await requireAuth();
    const { user } = authResult;

    const createPostSchema = z.object({
      subject: z.string().min(5).max(200),  // ← title → subject
      content: z.string().min(10).max(10000),
      category: z.enum(["general", "question", "debate", "news"]),
      politician_id: z.string().uuid().optional().nullable(),
      tags: z.array(z.string()).max(5).optional(),
    });

    const validated = createPostSchema.parse(body);

    const supabase = await createClient();
    const { data: newPost } = await supabase
      .from("posts")
      .insert({
        user_id: user.id,
        politician_id: validated.politician_id || null,
        subject: validated.subject,  // ← title → subject
        content: validated.content,
        category: validated.category,
        tags: validated.tags || null,
        author_type: 'user',
      })
      .select()
      .single();

    return NextResponse.json({ success: true, data: newPost }, { status: 201 });
  }
}
```

---

### 2. `/api/comments/route.ts` - POST 수정

#### 변경 전
```typescript
export async function POST(request: NextRequest) {
  // 1. 인증 필수
  const authResult = await requireAuth();
  const { user } = authResult;

  // 2. 스키마 검증
  const createCommentSchema = z.object({
    post_id: z.string().min(1),
    content: z.string().min(1).max(500),
    parent_id: z.string().optional().nullable(),
  });

  // 3. 삽입
  const { data: newComment } = await supabase
    .from('comments')
    .insert({
      post_id: validated.post_id,
      content: validated.content,
      user_id: user.id,  // 필수
      parent_id: validated.parent_id || null,
    });
}
```

#### 변경 후
```typescript
export async function POST(request: NextRequest) {
  const body = await request.json();

  // 1. author_type에 따라 분기
  if (body.author_type === 'politician') {
    // === 정치인 댓글 ===

    // 1-1. 스키마 검증
    const politicianCommentSchema = z.object({
      post_id: z.string().min(1),
      politician_id: z.string().min(8).max(8),
      session_token: z.string().min(64).max(64),
      content: z.string().min(1).max(500),
      parent_id: z.string().optional().nullable(),
      author_type: z.literal('politician'),
    });

    const validated = politicianCommentSchema.parse(body);

    // 1-2. 세션 토큰 검증
    const supabase = createAdminClient();
    const { data: session, error: sessionError } = await supabase
      .from('politician_sessions')
      .select('*')
      .eq('politician_id', validated.politician_id)
      .eq('session_token', validated.session_token)
      .gt('expires_at', new Date().toISOString())
      .single();

    if (sessionError || !session) {
      return NextResponse.json(
        { error: '인증이 필요합니다. 다시 로그인해주세요.' },
        { status: 401 }
      );
    }

    // 1-3. 게시글 존재 확인
    const { data: post, error: postError } = await supabase
      .from('posts')
      .select('id')
      .eq('id', validated.post_id)
      .single();

    if (postError || !post) {
      return NextResponse.json(
        { error: '게시글을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // 1-4. 대댓글인 경우 부모 댓글 확인
    if (validated.parent_id) {
      const { data: parentComment, error: parentError } = await supabase
        .from('comments')
        .select('id')
        .eq('id', validated.parent_id)
        .single();

      if (parentError || !parentComment) {
        return NextResponse.json(
          { error: '부모 댓글을 찾을 수 없습니다.' },
          { status: 404 }
        );
      }
    }

    // 1-5. 댓글 삽입
    const { data: newComment, error: insertError } = await supabase
      .from('comments')
      .insert({
        post_id: validated.post_id,
        user_id: null,
        politician_id: validated.politician_id,
        content: validated.content,
        parent_id: validated.parent_id || null,
        author_type: 'politician',
      })
      .select()
      .single();

    if (insertError) {
      return NextResponse.json(
        { error: '댓글 작성 중 오류가 발생했습니다.' },
        { status: 500 }
      );
    }

    // 1-6. last_used_at 업데이트
    await supabase
      .from('politician_sessions')
      .update({ last_used_at: new Date().toISOString() })
      .eq('id', session.id);

    return NextResponse.json({ success: true, data: newComment }, { status: 201 });

  } else {
    // === 일반 회원 댓글 (기존 로직) ===

    const authResult = await requireAuth();
    const { user } = authResult;

    const createCommentSchema = z.object({
      post_id: z.string().min(1),
      content: z.string().min(1).max(500),
      parent_id: z.string().optional().nullable(),
    });

    const validated = createCommentSchema.parse(body);

    const supabase = await createClient();

    // 게시글 존재 확인
    const { data: post, error: postError } = await supabase
      .from('posts')
      .select('id')
      .eq('id', validated.post_id)
      .single();

    if (postError || !post) {
      return NextResponse.json(
        { error: '게시글을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // 대댓글 확인
    if (validated.parent_id) {
      const { data: parentComment, error: parentError } = await supabase
        .from('comments')
        .select('id')
        .eq('id', validated.parent_id)
        .single();

      if (parentError || !parentComment) {
        return NextResponse.json(
          { error: '부모 댓글을 찾을 수 없습니다.' },
          { status: 404 }
        );
      }
    }

    // 댓글 삽입
    const { data: newComment } = await supabase
      .from('comments')
      .insert({
        post_id: validated.post_id,
        content: validated.content,
        user_id: user.id,
        parent_id: validated.parent_id || null,
        author_type: 'user',
      })
      .select()
      .single();

    return NextResponse.json({ success: true, data: newComment }, { status: 201 });
  }
}
```

---

### 3. GET 엔드포인트 수정

#### `/api/posts` - GET
```typescript
// posts 조회 시 정치인 정보도 조인
let queryBuilder = supabase
  .from('posts')
  .select(`
    *,
    users:user_id (
      name,
      email
    ),
    politician:politician_id (
      name,
      party,
      position
    )
  `, { count: 'exact' });

// ← "title" → "subject" 변경 필요 없음 (SELECT *로 가져오므로)
```

#### `/api/comments` - GET
```typescript
// comments 조회 시 정치인 정보 추가
let queryBuilder = supabase
  .from('comments')
  .select(`
    *,
    users:user_id (
      name,
      email
    ),
    politician:politician_id (
      name,
      party,
      position
    ),
    posts:post_id (
      subject
    )
  `, { count: 'exact' });

// ← "posts.title" → "posts.subject" 변경
```

---

## 구현 계획

### Phase 1: 데이터베이스 마이그레이션 ✅ (준비 완료)

**파일:** `1_Frontend/migrations_to_apply.sql`

**작업:**
1. ✅ politicians 테이블에 verified_email 추가
2. ✅ posts.title → posts.subject 변경
3. ✅ posts.user_id NULLABLE 변경
4. ✅ posts.author_type 추가
5. ✅ comments.user_id NULLABLE 변경
6. ✅ comments.politician_id 추가
7. ✅ comments.author_type 추가
8. ✅ politician_sessions 테이블 생성
9. ✅ CHECK 제약 조건 추가

**적용 방법:**
```bash
# Supabase Dashboard > SQL Editor에서 실행
psql -h [host] -U postgres -d postgres < migrations_to_apply.sql
```

---

### Phase 2: 인증 API 수정 ✅ (완료)

**파일:**
- `src/app/api/politicians/verify/send-code/route.ts` ✅
- `src/app/api/politicians/verify/check-code/route.ts` ✅

**변경 사항:**
1. ✅ send-code: politician_id + email 방식으로 변경
2. ✅ send-code: verified_email 검증 로직 추가
3. ✅ check-code: 세션 토큰 영구 발급 (2099-12-31)
4. ✅ check-code: verified_email 저장 로직 추가

---

### Phase 3: 게시글/댓글 API 수정 ⏳ (진행 예정)

#### 3-1. `/api/posts/route.ts` 수정

**작업:**
1. ⏳ author_type 분기 로직 추가
2. ⏳ 정치인 글쓰기 로직 구현
3. ⏳ 세션 토큰 검증 로직 추가
4. ⏳ "title" → "subject" 변경
5. ⏳ 기존 회원 글쓰기 로직 유지

**예상 소요 작업량:**
- 코드 작성: 200줄 추가
- 테스트: 10개 케이스

---

#### 3-2. `/api/comments/route.ts` 수정

**작업:**
1. ⏳ author_type 분기 로직 추가
2. ⏳ 정치인 댓글 로직 구현
3. ⏳ 세션 토큰 검증 로직 추가
4. ⏳ 기존 회원 댓글 로직 유지

**예상 소요 작업량:**
- 코드 작성: 180줄 추가
- 테스트: 8개 케이스

---

#### 3-3. GET 엔드포인트 수정

**작업:**
1. ⏳ `/api/posts` GET: 정치인 정보 조인 (이미 있음)
2. ⏳ `/api/comments` GET: 정치인 정보 조인 추가
3. ⏳ "posts.title" → "posts.subject" 참조 변경

---

### Phase 4: 프론트엔드 컴포넌트 구현 ⏳ (진행 예정)

#### 4-1. 정치인 선택 컴포넌트

**파일:** `src/components/politician/PoliticianSelector.tsx` (신규)

**기능:**
- 정치인 목록 드롭다운
- 선택 시 localStorage 세션 확인
- 세션 있으면 → 글쓰기 화면
- 세션 없으면 → 이메일 인증 화면

---

#### 4-2. 이메일 인증 컴포넌트

**파일:** `src/components/politician/EmailAuth.tsx` (신규)

**기능:**
- 이메일 입력
- 인증 코드 발송
- 코드 입력 및 확인
- 세션 토큰 localStorage 저장

---

#### 4-3. 정치인 글쓰기 컴포넌트

**파일:** `src/components/politician/PoliticianPostForm.tsx` (신규)

**기능:**
- 제목/내용 입력
- 카테고리 선택
- 태그 입력
- 제출 시 session_token 포함

---

#### 4-4. 정치인 댓글 컴포넌트

**파일:** `src/components/politician/PoliticianCommentForm.tsx` (신규)

**기능:**
- 댓글 내용 입력
- 제출 시 session_token 포함

---

### Phase 5: 통합 테스트 ⏳ (진행 예정)

**테스트 케이스:**

#### 5-1. 정치인 최초 등록
1. 정치인 선택
2. 이메일 입력
3. 코드 발송 및 확인
4. verified_email 저장 확인
5. 세션 토큰 저장 확인

#### 5-2. 정치인 글쓰기 (최초)
1. 이메일 인증 완료
2. 글쓰기 화면 진입
3. 제목/내용 입력
4. 제출
5. DB 저장 확인 (user_id=null, politician_id 있음)

#### 5-3. 정치인 글쓰기 (2회차)
1. localStorage 세션 확인
2. 바로 글쓰기 화면
3. 제목/내용 입력
4. 제출
5. DB 저장 확인

#### 5-4. 정치인 댓글 쓰기
1. 세션 확인
2. 댓글 입력
3. 제출
4. DB 저장 확인 (user_id=null, politician_id 있음)

#### 5-5. 다른 사람의 정치인 가로채기 시도
1. 다른 이메일로 인증 시도
2. "등록된 이메일과 일치하지 않습니다" 에러 확인

#### 5-6. 일반 회원 글쓰기/댓글 (기존 기능)
1. 회원 로그인
2. 글쓰기/댓글 작성
3. DB 저장 확인 (user_id 있음, politician_id=null)

---

## 요약

### 현재 상태
| 항목 | 상태 | 비고 |
|------|------|------|
| DB 마이그레이션 | ✅ 준비 완료 | `migrations_to_apply.sql` |
| 인증 API | ✅ 완료 | send-code, check-code |
| 게시글 API | ⏳ 진행 예정 | POST 수정 필요 |
| 댓글 API | ⏳ 진행 예정 | POST 수정 필요 |
| 프론트엔드 | ⏳ 진행 예정 | 컴포넌트 신규 작성 |

### 핵심 변경 사항
1. ✅ **posts.title → posts.subject** (필드명 변경)
2. ✅ **user_id NULLABLE** (정치인은 user_id 없음)
3. ✅ **politician_id 추가** (comments 테이블)
4. ✅ **author_type 추가** (posts, comments)
5. ✅ **영구 세션** (2099-12-31 만료)
6. ✅ **verified_email** (최초 1회 인증)

### 다음 단계
1. ⏳ Supabase에 마이그레이션 적용
2. ⏳ `/api/posts/route.ts` 수정
3. ⏳ `/api/comments/route.ts` 수정
4. ⏳ 프론트엔드 컴포넌트 작성
5. ⏳ 통합 테스트 수행

---

**작성일:** 2025-12-02
**문서 버전:** 1.0
**작성자:** Claude Code
